 This is Security Now with Steve Gibson, episode 22 for January 12, 2006, the Windows Metafile
 backdoor.
 Leo Laport here with Steve Gibson, we're back again and once again we're going to put
 off our discussion of how the internet works because we've got a blockbuster story for
 you tonight.
 Yeah, we have to delay again, again, we'll always do what needs to be done and then get
 back to our regularly scheduled programming.
 Okay, so first let's just circle back to previous episodes, catch up with anything we left
 out there.
 Anything you want to update?
 There were a couple of things in my category of errata.
 Someone made the point that I refer to hackers as hackers rather than as crackers.
 Oh, we get this every time.
 I get this so often.
 That's interesting.
 Yeah, exactly.
 So I wanted to say something about it.
 For me, the term cracker, just I don't know, it sounds like what African Americans refer
 to white guys as or like a saltine, it just doesn't seem serious and evil and so I try
 to say malicious hacker, but on the fly, when you and I are talking, I just say hacker.
 The point these guys are trying to make is that the hacking profession is an old and honorable
 one.
 If the internet wouldn't exist without hackers, Unix wouldn't exist without hackers.
 I mean, hacking is not in and of itself bad.
 So when we say talk about bad guys as hackers, they feel like we're besmirching the hacking
 community.
 Exactly.
 I mean, it's, well, and it's two things.
 It's a shorthand and also whether these people, these purists, the hacker purists like it
 or not, the definition, the sort of the publicly accepted definition of hackers is changing
 to the dark side.
 So for example, when I talk to people not in the industry, not who are not like saying,
 wait a minute, do you mean a malicious hacker or one of those good guy hackers?
 You know, I mean, they know that hackers are bad.
 And so I think you can tell, the English is a very subtle language.
 You can tell from the context, we don't have to tell you, we're talking about good hackers
 or bad hackers.
 We are both and just listen to what we're saying and I think it'll be obvious.
 What I say when people, and I get this all the time still, and I just say, look, we're
 trying to communicate in a language, a common language.
 And if most people don't understand cracker and they do understand hacker, that's the
 word we're going to use.
 You're just going to, we're going to have to trust you and your good brains to figure
 out what kind of things are going to happen.
 And we started saying cracker all the time.
 Sorry, it's not going to cause a lot more confusion.
 Very confusing.
 Just saying.
 What are they talking about?
 Yeah.
 Okay.
 I think it's going to be a lot of hackers.
 I consider Steve a hacker of the best kind.
 I mean, hack away a code.
 And I've done a little hacking in my time, but none of them, neither of us have, to my
 knowledge anyway, cracked into other people's computers.
 That's a different kind of hacker.
 You know, the second thing here in erratic category is many people followed the advice
 from two weeks ago, where, which was Microsoft's initial advice about this Windows Metafile
 vulnerability of unregistering that shell image viewer DLL, S-H-I-M-G-V-W dot D-L-L.
 And after the Microsoft patch came out last week, early, as we know, they couldn't find
 the instructions for re-registering.
 So, I mean, it's simple to do.
 It's regserve32 space S-H-I-M-G-V-W dot D-L-L, does it?
 In fact, it's probably in your run command.
 If you scroll down, you'll see the one with a dash U, which means unregister, just remove
 the dash U and it re-registers it.
 But I've also given the complete instructions, which were on the show notes for 20.
 I've moved just the re-registration part over to the show notes for today's show for
 episode 22.
 So, anybody who wants to get it directly from the web page, just go to the show notes
 for 22 and Leo, I imagine you might want to put that on your page too.
 I will.
 Because lots of people have said, "Hey, I've lost all my thumbnails.
 Now what do I do?"
 And that was a bad fix from Microsoft.
 It didn't really fix the problem and there's a better fix.
 In fact, ill-facts fix was better and now Microsoft's fix.
 And by the way, does Microsoft's fix work still?
 I mean, are we still happy with it?
 Oh, yes, what they did was to remove this feature, which is what I think it actually
 is from Windows after it was discovered.
 Now let's, you just said something and I think we can move on.
 Are you ready to move on to the?
 Yeah.
 Okay, let's talk about when you said what I think it really is.
 Well, remember that last week, the way things ended was we weren't sure whether Microsoft
 was going to fix the earlier versions of Windows.
 They were saying that they were offering a fix for Windows 2000, XP, 64, 2003, but not
 for the older versions of Windows because the problem wasn't as bad on those machines.
 They said, "There is the problem there, but it's not as bad," whatever that means.
 And so I made the statement, "Hey, if Microsoft ends up not fixing this, I'm going to fix it."
 Because who wants to be using a machine, no matter how old it is, where you go to a website
 and display a bad image and get your machine taken over.
 That's not okay.
 Even though it takes more apparently on those machines to display a Windows Metafile image,
 you have to have, you know, something needs to have registered the handling of Windows
 Metafiles.
 But you know, the IrfanView program is a known way of displaying Metafiles that is vulnerable,
 and many people use that.
 Yeah.
 So this confirms that you are vulnerable if you're using Windows 95, 98, or ME.
 Is that right?
 You are vulnerable to the WMF flaw if you have something that can view Windows Metafiles.
 I'm still not sure, and this sort of leads us into what I've been doing for the last
 week and what I've discovered.
 What I decided to do was, you know, we should say that Microsoft, as most people probably
 know who are running the older versions of Windows, they have been left out to dry.
 What happened was, Microsoft's original vulnerability report on their page listed all the versions
 that were affected by this Windows Metafile vulnerability, and I'm putting vulnerability
 in quotes now so you can hear those quotes around vulnerability.
 What happened later is that they moved Windows, the earlier versions of Windows, 98, second
 edition, and ME, and NT out of that category.
 Well, it turns out that in the process of doing that, it became a non-critical vulnerability
 by their definition, and their definition for what's critical is sort of amazing.
 I mean, and this is from a page on their website.
 They say a vulnerability in Windows is critical only if its exploitation could allow the propagation
 of an internet worm without user action.
 In other words, anything else is not critical, which is surprising because many of their
 patches in fact, they call critical, although they don't allow the propagation of internet
 worms.
 Exactly.
 Why are they fudging it like that?
 It's amazing.
 And so get this.
 The next level down from critical is an important severity rating.
 An important severity is a vulnerability whose exploitation could result in compromise of
 the confidentiality, integrity, or availability of users' data, or the integrity, or availability
 of processing resources.
 So a root kit is actually not a critical vulnerability, it's just an important vulnerability.
 Very good point.
 So I mean, they--
 In Microsoft's language, which is clearly absurd.
 Well, they've defined this so that, I mean, almost nothing now is a critical vulnerability.
 And then by moving the older versions of Windows out of that category, they said, "Oh, well,
 yes, we've agreed that we will patch older versions of Windows critical vulnerabilities,
 but we're no longer maintaining those older versions for non-critical vulnerabilities."
 In other words, this allowed them last week to say, "Oh, this Windows Metafile exploit
 is non-critical."
 So the older versions of Windows, we're not going to fix.
 In their defense, I guess what you could say is, "Well, if people choose to run an
 old out-of-date operating system, we really can't be held accountable for it unless it
 impacts the health of the Internet."
 In other words, if you choose to run an old operating system, we're not going to protect
 you, but we will do our duty and protect the Internet.
 I mean, that's not unreasonable, is it?
 And I also agree that, you know, it makes sense for them to set some sort of sunset provision
 here where they're not being obligated to, like, for example, go back and patch Windows
 3.0, or 95.
 The real legacy OS is that, sure, you could have put that on the Internet, but it's just
 so old, you know, where does Microsoft's responsibility end?
 So, you know, I'm not arguing, I guess, with this, but if, in fact, these machines are
 vulnerable, then I had committed and I believe I should fix them for people because Microsoft's...
 It was very clear then last week was not going to.
 And, by the way, even if Microsoft doesn't consider it critical, certainly everybody else
 does, including the users who are susceptible to this.
 Well, and there's still millions of Windows 9x and ME systems out there, I mean, actively
 on the Internet, that are now in some sort of unknown limbo state.
 So, over the weekend, I rolled up my sleeves and sort of switched into what was really
 hacker mode, you know, normally I'm writing code, now it's like, okay, I'm going to do
 sort of follow-in ill-facts footsteps and I wanted to acquire an understanding of exactly
 what this problem was in order to create a...
 In order to determine for myself first, if, in fact, these older versions of Windows were
 actually vulnerable, and then if so, I would have a...
 Certainly have a head state on how to cure that vulnerability.
 So, I started with what was known, which was the vulnerability in our existing versions
 of Windows, you know, 2000 XP and so forth, and basically created from scratch my own
 GRC-style vulnerability testing tool, and, you know, there was, you know, code snippets
 from the hacking sites, and ill-fact had, in fact, published the source for his tester.
 Mine ends up working differently because, again, I wrote it from scratch, I have a different
 approach, but I had a hard time getting this vulnerability to trigger.
 I was creating meta files, I was using this, you know, this escape set abort proc procedure
 that we knew was sort of the vector of exploitation.
 Mine wasn't working.
 And this is in Windows 98, you're talking about?
 No, this is in Windows 2000.
 Oh, you couldn't even get it in 2000.
 I removed the patch from my system, and I could not get the exploit to trigger using
 a meta file that I created with my own code.
 It just, you know, it came back and said it could not play the meta file, but it wouldn't
 run any of my own code.
 So, you know, I scratched my head, I looked at the other samples of malicious meta files,
 and, you know, the way a meta file is built is there's a header, a set of bytes that's
 the header that talks about what version of Windows it's using, how large the whole
 meta file is, what the size of the largest meta file record contained within the meta
 file is, sort of, it gives some Windows some orientation for the subsequent processing
 of these meta file records.
 Then you have a series of meta file records where each one starts out with a 4 byte size
 of that record in words, then a 2 byte function number, which is what type of meta file record
 this is, then followed by between zero or however many data that function requires.
 So it's pretty straightforward.
 Well, it turned out that, first of all, the way this, this escape function was working
 was, it didn't strike me as like erroneous, that is, what this set escape abort, sorry,
 the escape set abort proc function does.
 The idea is that when, when an application is printing to the printer, it creates something
 called a device context, I got to get a little bit tricky here with Windows terminology,
 but everyone will be able to follow along.
 It creates a, what's called a printer device context, where things like the thickness of
 the pen, the color of the pen, the size of the paper, sort of all the things that are
 about the context of this printing page are stored.
 So, once the application has a page ready, it turns it over to Windows and says, okay,
 here go print this.
 And essentially, it's done with that page and it gets on about its business.
 For example, maybe getting the next page ready to hand over to Windows to print.
 The problem is, what if the user aborted that page, that is, aborted the printing of
 the page after it had been handed over to Windows?
 The application that's doing the printing has already turned responsibility for the printing
 over to Windows.
 There's really no way for Windows to say, hey, oops, I just want to let you know the
 user canceled your print job.
 So, this set abort proc is a, it's a means for giving that printer context, that printer
 device context, a subroutine that Windows can call back in the application.
 It's called a call back, in fact, because Windows calls back the application to notify
 it if the user or something causes an abort of the print job.
 So, that's what it is, it's well understood, it makes complete sense in a printer device
 context.
 So, my understanding of it and the general understanding of it has changed a little bit.
 It is, it's just simply a call back routine that's designed for aborting a printing process,
 so that you can call back the calling program.
 Yeah, it basically, you're giving Windows a pointer, you're giving Windows a pointer
 to a subroutine in your code and telling Windows if the user aborts the print job and
 I've given you a pointer, then call that subroutine of mine, which is a way for Windows to notify
 the application.
 That's what that is.
 Right.
 Well, okay.
 First of all, it makes no sense at all in a meta file device context, in the context
 of processing a meta file, setting the printer abort is crazy, because it's not a printer
 context, you don't print meta file contexts in this way, it's just, it's not the way it's
 done in Windows.
 So, so it doesn't make sense, but it's like, okay, well, so maybe, you know, it's there
 anyway, they didn't think to remove it or take it out, except that when I was pursuing
 this and finally got it to work, what Windows did when it encountered this escape function
 followed by the set abort proc, um, meta file record, was it jumped immediately to the next
 byte of code and began to execute it, that is, it's, it wasn't, it was no longer interpreting
 my meta file records record by record, which is the way meta files are supposed to be processed,
 you don't actually execute the meta file, it's, as we said before last week.
 And I think the week before it's sort of a script, it's a script of, of Windows graphics
 calls that allow you to specify, you know, draw a rectangle from here to here, draw a
 line from there to there and it's, it's in a, in a nice sort of device independent fashion.
 So you don't run the code in the meta file, but what Windows did when it encountered this
 particular nonsensical sequence was to start executing the next byte of code in the meta
 file.
 And it's like, okay, wait a minute, why, you know, that's crazy, but what's even more
 crazy is what it took for me to make it do this.
 As I said before, each record in a meta file begins with a four byte length, followed by
 a two byte function number.
 So in other words, each meta file record has six bytes minimum that it can possibly be
 in size and if you, oh, and since the, the size is in words, the smallest possible size
 for a meta file record would be three words long or six bytes.
 The reason I had problems making this exploit happen initially is I was setting the length
 correctly, it turns out that the only way to get Windows to misbehave in this bizarre
 fashion is to set the length to one, which is an impossible value.
 I tried setting it to zero.
 It didn't trigger the exploit.
 I tried setting it to two, no effect, three, no effect and nothing, not even the correct
 length, only one.
 Now, why were you experimenting wasn't, isn't the exploit well known and documented and
 aren't there, isn't there exploit code floating around?
 No, I mean, what we've got Leo is a bunch of misunderstanding and sort of strange half
 explanations.
 So none of the hacker sites have exploit code up.
 Oh, no, many of them do, but no one is really looking, see, they don't care about how Windows
 is working, they just want to get their code to run.
 And so, you know, because I'm a developer when I'm not being a hacker, I wanted to
 understand, oh, and the other thing is I want to write a robust testing application, you
 know, that always works all the time.
 So I wanted to know, like, okay, what bytes have to be set, which way, what matters, what
 doesn't.
 Because, you know, that's the way you get something that is as solid as, you know, the
 code that I put out from GRC.
 So what I read, what I found was that when I deliberately lied about the size of this
 record and set it set the size to one and no other value, and I gave this particular
 byte sequence that makes no sense for a meta file, then Windows created a thread and jumped
 into my code, began executing my code.
 Okay, Leo, this was not a mistake.
 This is not buggy code.
 This was put into Windows by someone, we are never going to know who, we're never going
 to know.
 Well, actually, I'm going to find out when, because we're going to know when this appeared,
 because this appeared, I'm guessing this is not in older versions of Windows, which is
 why this function, or if it is in older versions of Windows, it's done slightly differently.
 I'm going to, I'm still on the hunt.
 So this is not my last report on this.
 I expect to have a much better sense for this a week from now, but the only conclusion
 I can draw is that there has been code from at least Windows 2000 on, and in all current
 versions, and even future versions, until it was discovered, which was deliberately put
 in there by some group, we don't know what level or how large in Microsoft, that gave
 them the ability, that they who knew how to get their Windows systems to silently and
 secretly run code containing an image, those people would be able to do that on remotely
 located Windows machines.
 So you're saying intentionally, or you just, does it have Microsoft intentionally put a
 back door in Windows?
 Is that what you're saying?
 Yes, well, that's a pretty strong accusation.
 Could this not have been a, it couldn't have been a mistake, I don't see how it could have
 been a mistake.
 I'm again, I'm going to continue to look at it, but from what I've seen now, this had
 to be deliberate.
 It is not what we were led to believe sort of, well, it's funny too, because then I thought,
 okay, wait a minute, Microsoft has lied to us.
 I reread the vulnerability, original vulnerability spec, and you know, their vulnerability page.
 And they never say this isn't the case, I mean, they describe it as a vulnerability,
 which is certainly is nowhere, you know, is even what I'm saying contradicted by their
 page.
 So you're saying Microsoft or people at Microsoft may be unbeknownst to Microsoft intentionally
 put code in Microsoft Windows that it will allow anybody who knew about it to access
 any Windows machine, to get into any Windows machine and run any arbitrary code on it.
 Well, it's not, you're not, it's not like a Trojan where they would be able to contact
 a remote machine.
 But for example, if Microsoft was worried that for some reason in the future, they might
 have cause to get visitors to their website, to execute code, even if active X is turned
 off, even if security is up full, even if firewalls are on, basically, if Microsoft
 wanted a short circuit, a means to get code run in a Windows machine by visiting their
 website, they have had that ability and this code gave it to them.
 And there was nothing anybody could do about it or in most cases detected.
 So what it sounds like, and I really want to be careful here, because this is a very
 serious accusation.
 It sounds like this was done on purpose by Microsoft or somebody at Microsoft, it sounds
 like it was accidentally discovered that Microsoft reactant has pulled it out now, right?
 May, could there be other back doors like this?
 Well, yes, I mean, that's the problem with a closed source operating system.
 Now I have to say, before we go any further, you're not an open source advocate, you're
 not a Macintosh advocate, you've been a Windows user and a Windows, and frankly, you're my
 staunchest friend who is a Windows advocate, I mean, so this is not some plan on your
 part to discredit Microsoft.
 Well, no, and in fact, I'm sure, I mean, I'm hoping that we're going to see corroboration
 from other people who didn't think about or didn't look closely at this.
 I mean, frankly, if last week Microsoft had patched the older versions of Windows, I
 would have had no cause to look closely, to understand how this exploit worked that was
 discovered.
 I believe that some very clever and industrious hacker figured this out, started using it,
 and Microsoft was caught off guard and thought, whoops, we've got to close this backdoor
 down.
 Now, to say that Microsoft did this, I mean, on one level, it's clearly true, but we don't
 know who knows about this in Microsoft.
 He could have been a renegade programmer working for Windows who just thought he'd throw this
 in for fun.
 Yes.
 I mean, let me ask you one more time though.
 But that's dangerous too.
 Well, of course.
 But let me ask you one more.
 There's no, you're convinced there's no way this could have happened by accident.
 It can't be a programming error or bad design.
 No, no, I mean, you know, again, this is as much a surprise to me, Leo, as it is to,
 you know, anyone who hears this, I did not expect to see this.
 I expected to find, for example, that I would give it that the way this exploit worked was
 that the set of board proc was working correctly and that I would give it a pointer to my own
 code a few bytes lower, then I would do something to force the metafile to abort and then if
 the metafile processing would use the pointer, the legitimate set abort proc pointer and then
 basically run the code that was located right there in the metafile.
 That's what I thought I was going to encounter, something that sort of made sense.
 Like we were originally led to believe or actually I think, you know, Microsoft didn't
 say anything at all.
 So we just all kind of presumed this was another one of those coding errors that Microsoft
 now famously makes and corrects on the second Tuesday of every month.
 This wasn't a programming error and, you know, so it's like, whoa, when I give it the magic
 key on the size of the metafile record, then it jumps directly into my code.
 Now again, I'm, I'm, I will know more in a week.
 I have to say that, you know, this we, I want to call this preliminary, but I don't see
 any way that this was not something that someone in Microsoft deliberately put into
 Windows and, you know, this has been at the request of a government agency.
 Let's say, I guess not because as you point out, it's not a Trojan horse.
 You have to go to a site.
 You have to go to the site of somebody who knows about this exploit to be taken advantage
 of. And in fact, the scenario you describe is really the only scenario I could think
 of Microsoft doing it so that if worst case happened, they would be able to update a machine.
 They'd be able to say, go to the Microsoft site and we'll fix you or something.
 I mean, it's the NSA wouldn't put this in because they couldn't guarantee access to
 any computer.
 I've looked back over all the documentation.
 I can't find anything about this documented anywhere.
 Okay.
 Then I said I played my own devil's advocate, okay, so code is running in the meta file.
 Wouldn't that be useful?
 Wouldn't it be useful if a meta file could contain executable code sort of as an undocumented
 feature?
 Microsoft never got around to writing about it, but they said, oh, this would be cool.
 And we'll use the set of board proc.
 Notice that set of board proc, it was just, I mean, this has nothing to do with printer
 aborting, it was just sort of a, it was a value that they had handy from other processing
 and they sort of reused it, but this has got nothing to do with aborting printing.
 This is so an almost, it almost helped with the obfuscation and sort of, you know, the
 plausible deniability accepted this wasn't a coding mistake.
 And you know, and you even had to put the magic key into the length of the record in
 order to get this to work so that, and that was protection from somebody's meta file having
 a set of brought abort proc, right, meta file record in it and tripping over this backdoor
 by mistake.
 This is exactly what you would do.
 If you were going to write a backdoor, this is exactly how you would do it.
 Yeah.
 Yeah.
 So, so I asked myself, isn't there like a constructive purpose for putting code in a
 meta file?
 And the problem is code running in the meta file doesn't have access to the context of
 the meta file, it's, it doesn't, it doesn't know what to do with it.
 It's, you know, it's, it's, it's powerless to, to, to use the objects that Windows is
 using and there seems to be no way to get back to Microsoft's code from this.
 Again, I've got some more work to do, you know, and then the timing of this security
 now podcast coincided with, you know, I've, I've known this for a day now and I've been
 going back over it and trying to come up with a, a reason, well, I mean, a benign reason
 for this.
 And I just don't see it.
 I suppose we should contact Microsoft and ask them what they think about this, but I doubt
 that we get a straight answer.
 I've tried doing that before on other issues like this Leo and you know, it's, it's not
 useful.
 So in this case, you know, Microsoft's often says, well, don't reveal this stuff because
 give us a chance to fix it because it could be a security issue.
 But the, the security issues already been revealed.
 We're not revealing anything that isn't already known.
 We're just asking why is it in there?
 Yeah.
 And the answer is not very encouraging.
 It does make you think maybe open source is a better way to go for an operating system.
 At least if we're in there, somebody would have had a chance to see it.
 Well, and, and setting this length of the Metafile record to one, that breaks the Metafile
 processing.
 It's not possible to like execute some code, then go back and finish things up gracefully.
 I mean, you've got a thread running on your own code in your own image.
 And everything is like over at that point.
 I mean, it just, it makes no sense.
 Have you contacted anybody in the security community to ask them about this?
 No, everyone hearing this will be learning about it from our podcast for the first time.
 We've got a bit of a scoop here.
 And I want to reserve judgment and give Microsoft the benefit of the doubt, prove to us why
 this isn't an intentional backdoor in Windows and reassure us that there are any more.
 Well, I mean, as you mentioned a couple of times here, I mean, the, one of the advantages
 of an open source system is, you know, and I'm finding myself gravitate gravitating more
 and more toward open source solutions because of their transparency.
 And so, you know, but an advantage of that is that all kinds of people are looking at
 the code and there's just no opportunity to, especially when you build the system yourself
 from source, there's no opportunity for anything evil to get stuck in.
 And also about this, what appears to be a Windows Metafile backdoor that's always been
 in Windows from 2000 on, you know, they've done recently serious security reviews of
 all their code, you know, they took that whole time out from all the work they were going
 to be doing and said they were rereading all their code.
 And this is not the first time Metafiles have had a problem.
 There have been what are probably real bugs in Metafile processing in the past.
 I think two of them, so the whole Metafile system would have come under the scrutiny
 of someone, you know, very deliberately.
 Now, you know, if Microsoft had said last week, whoops, this was an undocumented backdoor
 or means for us to run code in a Metafile.
 We never documented it.
 Our security sweeps didn't find it, blah, blah, blah.
 But nothing was said, they allowed the industry to believe that this was just like all their
 other code mistakes.
 But this wasn't like all their other code mistakes.
 That's a very serious indictment of, if not of Microsoft, maybe of a renegade programmer
 inside Microsoft.
 If you were doing a code review with this kind of things stand out, would it be fairly obvious
 that something was going on?
 Yeah, I mean, I've seen Microsoft source code in the old days I used to publish the
 source for what's called the DDK, the device driver kit.
 And you know, they're very cautious about, you know, on a module, my module basis, there's
 the person's name or initials and when they made changes and what they made to the code
 that follows.
 So I mean, again, Leo, we're never going to know for sure.
 I mean, I've been in this position with Microsoft in the past or similar positions.
 And you know, it's very difficult to get a straight answer from them.
 So I don't know what their source says, but it seems to me that somebody had to have seen
 relatively recently, certainly since 2000, had to have looked at the code, seeing that
 this was something that was there and just kind of nodded to himself and said, yep,
 that's what we want to have in our metafile processing code.
 Wow.
 Well, I'm sure we'll hear more about this.
 I think you probably are going to stir up a hornet's nest here.
 And if Microsoft would like to come on the show and respond, you absolutely are welcome
 to do so.
 I'd like to hear an explanation.
 I'm going to continue looking at this.
 The unanswered question is, when was this installed in Windows?
 My hunch is it actually wasn't ever in the earlier versions of Windows.
 I'm going to look for it and see what I can find.
 But it feels to me like this was something added later and that the older versions are
 in fact not vulnerable and have never been vulnerable.
 But again, I haven't looked there.
 I don't know for sure, I haven't also looked at Windows code itself.
 So far, my work has just been from the outside poking at this, trying to get the behavior
 from Windows that I expect.
 So again, it may be that a week from now, I come back with my tail between my legs and
 say, Leo, I told what I believe to be the case at the time.
 Now I see how this makes sense and something that I see in the code didn't occur to me.
 I haven't done that yet.
 So that's what I'll be doing.
 We'll certainly know more in a week.
 But everything to me looks like this had to have been put in Windows in many versions
 of Windows for a long time and that someone just discovered it, so Microsoft had to take
 it out.
 Wow.
 Well, that's a blockbuster, that's a real bombshell Steve Gibson.
 Of course, at this point, the good news is Microsoft has released a patch that fixes
 it and so we don't have to worry about at least this back door.
 As a matter of fact, my little tester is finished.
 It's still going to undergo more development.
 But since I believe this is a back door, my tester is called Knock Knock.
 And you can get that at grc.com/securitynow.html.
 That's where you can also get the show notes, the transcripts and the 16-kilobit versions
 of this show.
 Of course, we thank the folks at AOL Radio and their podcast channel for broadcasting
 the show and for providing us with bandwidth for the download.
 Quite a blockbuster Steve Gibson, I don't know what the reaction is going to be, but I can
 tell you there's going to be one and we'll continue to cover this.
 This is the way it looks to me.
 I do want to mention that this Knock Knock XE is still in development.
 It currently only runs on the newer versions of Windows because that's all that my research
 has extended to so far and it's when I got that running that I realized the implications
 of what I had to do in order to make that work.
 Just to reassure us, you can't use Knock Knock as a hacker tool.
 It will just let you know the vulnerability is there.
 It's not a hacker tool.
 It works similar to Ilfak's vulnerability test, although it executes the code in a different
 way.
 I retain control of the program whereas Ilfak's terminated the program after presenting the
 user with a little dialog box.
 Mine actually validates that a thread was created by Microsoft and allowed to run in
 my Metafile image, also mine will not trigger people's AV scanners, whereas other vulnerability
 testers do.
 However, I want to make sure people understand this is not in our normal freeware files list.
 This is not linked from my home page.
 This is for people who are listening to security now who want to play with this little tester
 that runs under Windows 2000 XP and has been checked under the 64-bit version both with
 a vulnerable and non-vulnerable machine.
 Several people wrote saying that after applying Microsoft's patch, they still believed they
 were vulnerable.
 I think it had to have been pilot error like they forgot to reboot Windows afterwards
 or something because you do have to reboot Windows after applying the patch.
 My little program that this little Knock Knock dot XE will tell you for sure on the later
 versions of Windows if you're vulnerable or not to this, and then I'm going to be doing
 the research finally to extend this to the earlier versions.
 And as you said, we may find out more about how this happened in Windows.
 I don't think we've heard the whole story so far, Leo.
 Headline reads, "Security expert Steve Gibson says Microsoft intentionally put a backdoor
 in Windows 2000 and Windows XP, film at 11."
 In 2016, basically all the versions from the time it first appeared.
 Wow.
 We'll see you soon for more on this one and we'll be back next Thursday with another
 edition of Security Now.
 Steve, I'll make sure you lock your door tonight.
 [MUSIC PLAYING]
