 [MUSIC]
 This is Security Now with Steve Gibson, episode 33 from March 30th, 2006, Symmetric Block Cyphers.
 [MUSIC]
 >> Hello, Steve Gibson.
 >> Hey, Leo, great to be back with you.
 >> Are you swamped with answers to your stomach from last week?
 >> I thought I was getting a lot of postings on the security now page before.
 I mean, the really cool thing is people have had a lot of fun with this.
 I mean, I've received things that look like PhD thesis with pages covered in mathematical expressions with XORs and proofs of why it does work that you can communicate, but why it's not secure.
 We had a housewife who said she's out walking her dog listening to our podcasts, and either we're doing too good a job teaching or these puzzles are not hard enough, and then she completely explained why this is not secure.
 I mean, she got it right.
 >> Oh, yeah, and in fact, many people pointed out that one of the problems is that this is an abuse of the idea of a one-time pad.
 Essentially, it's been used as a two-time pad because people are using that pad twice.
 >> Well, let me repose the stomper so people know what we're talking about in the case.
 They missed episode 32, and then you can explain why it doesn't work.
 >> Well, in fact, if they missed episode 32, they ought to go back and listen to the beginning of it because they're like, stop now, go listen to the beginning of it, and you can have a puzzle all over again.
 >> Yes, that's true.
 Then you won't know the answer.
 That's fun.
 In fact, I think we should do this more.
 I think people really like it.
 So the premise was we were talking about one-time pads a couple of episodes ago, and how they really work.
 But the issue was you have to get the pad to the recipient so that he or how to get a copy of the recipient, and there's a vulnerability because in that transmission of the one-time pad, somebody could get it.
 So somebody suggested, well, here's a clever idea.
 Why don't you double encrypt?
 So you have two individuals with independent one-time pads, individual A encrypts using his one-time pad, sends it to individual B, who encrypts it using his one-time pad, sends it back to individual A.
 Am I right so far?
 >> Yeah.
 >> And then individual A decrypts his portion, sending it, now it's still encrypted, sending it back to individual B, who then decrypts it with his portion.
 And at no point was clear text sent back and forth, nor was the one-time pad exchanged.
 And you didn't even say that there was something wrong with this, you just said, would this work?
 >> Well, because that was the question posed to me by a listener after our previous episode.
 So it's like, okay, let's let this open to question, you know, does it work?
 And several people commented that, you know, yes, it works, that is, it does always transmit an encrypted message.
 And because of the nature of this simple or encryption or adding and subtracting, you are able to do these out of order.
 Now, normally, if you encrypted something and then you encrypted it again, you would not be able to decrypt it with the first key.
 That is, you always have to back yourself out in the same sequence of, you know, like in the reverse order of sequence of decryption from encryptions in order to, like,
 completely reverse the process. But because this is a simple X or, or an adding and subtracting, you know, like going back to our secret decoder ring,
 those operations are mutative and you are able to do them out of order.
 So, you know, person A encrypts, then B encrypts, then AD encrypts, which still leaves B's encryption, which is then the final process that decrypts.
 So in this simple case, it does work to do the encryption and decryption out of order.
 So the flaw isn't in that respect. Right. It does work.
 Yeah, here's the problem. We have to presume that there's an eavesdropper.
 I mean, that's the whole point of encryption anyway, is that we want to send an encrypted message that if somebody were to intercept it, it wouldn't help them.
 So an eavesdropper sees the message going from person A to B, which has been encrypted with persons A one time pad.
 They also then see the message going back from B to A, after B has encrypted it.
 Well, there's the problem because if you see the message before B encrypts it with his and after, the encryption is so simple that essentially you just, you, you, so you X or those two messages or you subtract one from the other and that gives you B's one time pad.
 So as our dog Walker pointed out, your flaw here is that you're using a one time pad twice.
 Well, yeah, and you're able to see the information. So by seeing the first and the second exchange, you're able to get the one time pad used by the second person.
 Then when the first person removes their encryption, the message is now only encrypted with the second person's one time pad, which you have.
 So now you simply decrypt it with that pad and you have that you've you've decrypted the message by by seeing it in transit.
 So this is clearly, I mean, it works, but it's anything but secure.
 You know, I think we have some very brilliant, mathematically inclined listeners because I wouldn't have gotten that.
 That's very people had a people had a lot of fun with it.
 In fact, a poster named Steve in Chicago also pointed out that I thought this was really cool is that the original concept that introduced this.
 The idea of a of a double lock box where where instead of using encryption, and this was what the original poster suggested, instead of using encryption, you'd put a lock on a box, send it to a friend like, okay, I lock a box, send it to you, Leo, you add your lock to it, send it back to me.
 I can't open the box, but I can't open the box, but I can put another lock on it.
 Exactly. Then you send it back to me, I remove my lock, leaving it now only locked with yours, which I send to you and you unlock. So it's locked the whole way and I don't need your key and you don't need my key.
 Yeah. And so anyway, a listener pointed out that is subject to a man in the middle attack, which I thought was really cool.
 Someone intercepts my sending it to you and and pretends to be you.
 And that's the problem with man in the middle attacks is a lack of authentication that I mean, that's the thing that is necessary in order to prevent this type of attack.
 So he puts his lock on it and he puts his lock on it. Yep, sends it sends it back to me, I remove mine, send it back to him, he removes his, now he opens it, takes a look at the inside, changes it, does whatever evil thing he wants to to it, now he pretends to be me sending it on to you.
 And so he basically does the same three-way handshake from him in the middle to you and you don't know you didn't get the contents from me.
 Right. So I thought it was just another very clever, real-world analogy to this kind of stuff.
 So that's exactly how a man in the middle attack works, interesting.
 Yeah. So we're going to continue on now. We have crypto to talk about. We've done 101 and 102.
 Oh, we got crypto for weeks, but there's just there's so much cool stuff in crypto.
 And what I think people are going to find is it's surprisingly straightforward.
 I mean, it seems like rocket science, you know, mumbo jumbo, confusing stuff, but, but essentially there are a series of simple building blocks, which each block is clear and easy to understand.
 And then once we have those, we're going to look at all the different ways they can be put together to do real work.
 And it's just, it's just so cool. I want to add one, one little note, a couple of people sent me and I'm sure you got the same emails recommendations for books along this line,
 two of which I've read and really can agree with are excellent.
 Simon sings the code book, which is a very good description of how crypto works and crypto through the ages.
 And then if you really want to know everything about how it's been used, David Kahn's classic code breakers is quite amazing.
 Well, those, those are good sort of literature oriented books.
 My Bible is Bruce Schneider's applied cryptography.
 And so I mean, he just is and and applied cryptography is, I don't know what, like fourth edition or fifth or sixth.
 I mean, I've got it in hardback and softback. I love it. It's, it's basically, it's the Bible of this stuff.
 I mean, it's, it's heavy duty technology. But if someone really wanted to understand, you know, without any, without any simplification, it just, Bruce lays it out.
 And it's, it's, it's a fantastic reference.
 Tell you what, I'll put links to all three books in the show notes and you can look at the Amazon reviews and decide which one is right for you.
 I'm not ready for code breakers. I mean, for Bruce's live cryptography code breakers and the code book, we're right for me.
 So, shall we, what are we going to talk about this week?
 Okay. This week is the second type of symmetric cryptography or symmetric ciphers or symmetric encryption, decryption known as block ciphers.
 What we, what we covered last week was are known as stream ciphers because,
 oh, wait, wait, no, as we, before last, I'm sorry, but before our Q&A episode two weeks ago, those were stream ciphers that, you know, taking a look at RC4, which of course is the famous one that was used in web, which because it was not used correctly,
 even though RC4 itself is a very good source for encryption, it was not applied correctly that, that the people who are applying this technology have to be aware of is, is using them correctly.
 You can have a really strong tool, which you don't use correctly and get yourself in trouble.
 So, so you've digressed a little bit, but what's the difference between a block cipher and a stream cipher?
 Well, that's where we're going to go right now.
 Okay.
 The, the idea was you'll remember we had basically a stream of bytes and we were, we had a, either, if we had a one-time pad, then we had a true source of random numbers.
 Or symbols that we were mixing with our message in order to produce a truly random result.
 So that was like a, the pad represented a stream of randomness.
 If we didn't have a one-time pad, we could instead use a, a, a cryptographically strong pseudo random number generator.
 So this again, just every time you ask this generator for a new random number, it hands you one.
 And the, the idea being that a, a very good mathematical algorithm is producing these so that no analysis of them can find a pattern.
 And there, and we know how to do that now.
 Our modern cryptography ran, in fact, RC4 for its simplicity, and it's a very simple random number generator, which is why it was originally adopted by the web guys in the beginning, was they wanted to be able to run this on very inexpensive low power hardware and low power machines.
 So it's very good.
 It turns out you have to look at millions and millions of, of the random numbers produced by it to even be able to tell it's not ping pong ball random.
 I mean, it's not truly absolutely random.
 It's that good.
 So the idea is you have a pseudo random number generator that just spits out this stream of random bits, which you mix in with your message, turning your message into ciphertext.
 Into essentially random bits.
 And then at the other end, of course, somebody with the same pseudo random number generator and the same key, because these are keyed so that the, the, the specific sequence of pseudo random bytes or bits that it generates is dependent upon the key.
 So they generate the same stream of pseudo randomness.
 They unmix it with the ciphertext returning into plain text. So that's stream ciphers.
 There's an, an, an entirely different way, which is actually become recently the dominant approach for cryptography for like bulk encryption.
 That's what SSL and open VPN. It's what the new WPA encryption uses basically stream ciphers are the kind of old school. They still have a place and they were a nice place for us to start.
 But now we're going to talk about what are called block ciphers.
 We'll start by going back to our decoder ring.
 Now with the decoder ring, we were, we, we set our wheels on the concentric circles of the ring to some position and basically just had a simple transposition.
 That is from any character, you'd move a certain number over to the other one.
 And that was encryption and due to decrypt, you just went in the opposite direction.
 Now imagine an entirely different approach. You have a, a table of, of every, every possible symbol in the alphabet.
 So you just write down A through Z down one column.
 Now on the other side, you just fill in the second column in a completely random sequence.
 So for example, you, you, you just somewhere on the second column, you put A somewhere else, you put B somewhere else, you put C somewhere else, you put D.
 So basically, you create a mapping between your, your clear text or plain text data and your cipher text.
 But in this case, there is no relationship between the columns.
 We shifted down or transposed from the other, making it, you know, very simple to, you know, like, you know, Caesars generals were able to decode this apparently.
 So the, so that the result is completely scrambled. Now that's a very, that's a perfect example of a very simple block cipher.
 Okay.
 Now, so, so again, you know, obviously the process of, of, of encrypting this is you find the symbol on the left.
 You just, and you simply do a table look up. You just look up the corresponding arbitrarily assigned symbol, but it, but it's statically assigned.
 That is every time you ask for the same symbol on the left, you're going to get the same symbol on the right. And so you, you produce your message.
 Now we have the same problem we've had before, that is to decrypt it, you need to get the person who's going to decode it has to have the same, basically a copy of that table.
 Okay. So we go to the first step, which is rather than creating, well, okay, I should, we have to talk about the weaknesses at this first. Obviously, this is not a very strong cipher.
 If you know anything about the language, because as we talked about before, even with the transposition cipher, if you did an analysis of the frequency of occurrences of these symbols, and you knew, for example, that the, that the message was probably going to be,
 be in ciphered English text, you just look at it and you say, oh, look at the, based on the frequency analysis, this symbol, you know, which might be Q, for example, is obviously E in English, because it's occurring so often.
 So it would be very simple to crack this simple mapping cipher, this very simple substitution, substitution cipher, exactly, or exactly, or block cipher by, by just doing an analysis of the frequency.
 Now, modern, so, so we have the idea of a random assignment. Well, now we have algorithms, which are becoming very popular and work very well, where a key automatically creates this mapping.
 So instead of sitting down and you, and just like randomly assigning these letters, we can use an algorithm to map from the plain text to the clear text, and that algorithm is driven by a key with a certain number of bits.
 And that, of course, is where we get our strength. Now, in order to solve this problem of the frequency analysis of the result being so simple, two things are done.
 The first is we don't use a single symbol block. That is, in this first example, the block, the so-called block length of our cipher was one symbol, one character, maybe eight bits, or actually, you know, if we were just using an alphabet, we could get away with 32 bits to hold the whole alphabet.
 Because, I'm sorry, five bits, because that's 32 possibilities, and that would be enough for A through Z space and dot and so forth. So, so the way we solve this, the, the, the frequency analysis problem is we encode many more symbols at a time.
 And temporary block ciphers are 64 bits long. So that's, for example, in, in terms of eight bit bytes, that's obviously eight characters. So when you take eight characters or eight symbols in a block, what you're doing, and this is what's fascinating
 about these algorithms is, I mean, 64 bits is a huge number of possibilities. We know that 32 bits is, is for gig. So that means that 64 bits will be 16 billion billion possible combinations.
 That seems like enough. Yes. And here's what's so cool is any any 64 bit combination you put in to one of these block and ciphering algorithms produces exactly one other that is one matching, but 64 bit combination.
 So, I mean, this is phenomenally strong, you put in, I'll say it again, you put in eight bytes at a time or 64 bits, and a completely different sort of like mapping to a different 64 bits comes out.
 And what's so cool is, if you just changed one bit on the input, just change one of those 64 bits from a zero to a one or one to a zero, what comes out is completely different. It's not like one bit over on the other side changes.
 Everything changes. It's just a completely different mapping. And that's what, oh, it's such cool technology. And that's, and that's what makes this so strong is even if you try to do an analysis of the frequency, you would just, you know, eight characters in England
 occur, you're not going to know where word boundaries are, even if you had like lots of E's and T's and S's, they're going to, they're going to be watered down by lesser occurring characters in their neighborhood so that you just, there's just no
 way to analyze the, the, the, the frequency strength of what's coming out and figure out what went in basically explains a lot to me because I'll look at an encrypted PGP message and the length doesn't even seem to correspond with the length of the clear text message.
 Well, and in fact, it won't because everything has to be done in blocks. So the size of the message will be rounded up to at least the next even block size in order to like finish off the message. If you might have like three characters after you're done chopping
 it up into, into sets of eight, and then you'd just have to pat it with an additional five in order to, for it to be an even number of blocks. So that's, that's one thing that's different about the use of a block cipher versus a stream cipher.
 As we've seen a stream cipher can be exactly as long as the message because you're just done when you're done even that gives you some information that's could be useful is the length of the message.
 Sure. Yeah. Sure. So, so what's so cool about these algorithms is that they, it's a virtual, you know, impossible to, to figure out mapping between a huge number of possible input combinations, you know, 16 billion billion
 and the same number of outputs. And of course, this is reversible. That is these algorithms. You have an encryption algorithm that goes one way, driven by a key.
 And the, the, the, the decryptor is typically a different algorithm because it's done so much to this data inside. But, but still you use the same key.
 Thus, it's a symmetric key cipher that is the same key drives a different algorithm in order to reverse this process. So it takes any one of this huge number of 64 bit inputs and unwinds it and returns it to what was originally put in.
 Now, the, the last thing that is done in order to further strengthen this is there, there's still, there's still be some weakness. If you had, if you had these eight bit blocks all standing by themselves.
 I mean, the problem has been made extremely difficult, but, you know, it's like, well, okay, maybe if you did analyze this, you could, you know, like, you had enough ciphertext and enough time.
 You could still do a frequency domain analysis of the result in order to see what was going on. So what they do is something called cipher block chaining, or CBC for short.
 And essentially what they do is they, they, they take the prior block and XOR that here we go with our favorite XOR operation again. You XOR it with the data for the next block before encrypting it.
 What that does is that creates an inter block, excuse me, an inter block dependency, so that no longer does do each eight bit block stand alone, which would potentially render it vulnerable to some sort of cryptographic analysis.
 Now you have to know what the, what the one before was in order to XOR that with the one that follows. So it's a reversible process.
 But it basically it means that if anything changes in the message, the entire message is destroyed. Whereas if we had eight byte block standing alone, something could change there and the rest of the message would not be hurt.
 So this, this strengthens the, the, the, um, in ciphering of the message, and it makes it, you know, way harder for, for someone to, to crypt analyze because they don't know what came before. So these individual blocks are not standing alone.
 Now, let's look a little bit at the history of this. The most famous block cipher is DES, the data encryption standard that was adopted by the US government and has been used, you know, widely for a long time.
 DES is a, is a very good and strong block cipher, but it suffers from a key length, which is too short. The, the DES algorithm uses only a 56 bit key.
 Now, once upon a time, that was a lot. But, you know, over the last decade, computers have gotten so much faster that 56 bits is no longer enough. And if, if somebody wanted to, if a, if a government, like government level funding produced a DES cracking machine hardware, and by the way, several have been produced.
 Um, then it's possible in a relatively short time to brute force attack the DES block cipher just because 56, excuse me, 56 bits of key doesn't give you enough possible combinations. You can just try them all, and you're going to be able to get there sooner later.
 So, what was done as sort of a one of the many improvements in general for block ciphering, something called triple DES, or 3 DES was created. 3 DES uses 256 bit keys and 3 DES operation.
 So, it takes the same, the, the same basic 56 bit encryption algorithm, but it uses it 3 times with 2 different keys. Well, these 2 different keys, essentially, the 256 bit keys form an effective single 112 bit key.
 And 112 bits is enough to give you today in today's world, there and, you know, for the foreseeable future, very strong encryption.
 So, so people have gone, many people have gone to triple DES as a nice way of, of strengthening DES and like bringing it up to, to current standards.
 So, they wanted to preserve the DES standard, but they wanted to make it more. So the strength of DES is that it's very easy to implement.
 Yeah, exactly. DES was chosen because it was fast and easy to implement, and it has been pounded on so much. See, it's like any brand new cipher might have a problem.
 This is the same thing we run into with security. It's like any brand new software, any brand new operating system, any brand new anything in security, you know, a brand new lock might have some way that the lock makers didn't think of for it to be cracked or hacked.
 You just don't know. It's really, it's only history and experience that allows us to prove the security of these technologies. So, sometimes better to go with it, try it into method, even if it has some flaws, just fix the flaw and continue to use it.
 Oh, absolutely. In fact, you know, every so often you'll see some website that's like bragging about, you know, their own, you know, hyper triple duty, you know, super triple scoop encryption.
 And it's like, what are you people thinking? You know, this problem has been solved already. I mean, and that's what I love about this is, you know, there are, there is a new standard.
 It's known as AES or the advanced encryption standard. It's actually a cipher called Rhindall. Rhindall was chosen from among a long list of ciphers in an international competition.
 So all these cryptographers who had their own favorite ciphers, I mean, and there are many block ciphers, you know, people have probably heard of Blowfish or actually Blowfish was invented by Bruce Schneider and he put it in the public domain.
 I mean, it's a very good, very strong block cipher. There's something called cast Krypton deal. DES, of course, we talked about DFC E2 frog HPC IDEA is the international data encryption algorithm.
 In fact, that's the bulk encryption used by PGP by the commercial PGP. It's licensed so it can't be used by the exactly source one.
 Loci 97 magenta Mars. Then there's RC2, which is a block cipher RC5 and RC6 and actually RC6 was one of the ones in the running for, for the AES.
 And that means safer and serpent and two fish. I mean, so the point is there's, you know, there's a whole pot of really good block ciphers.
 And what WPA uses, it can use, as we've talked about before, when it's running on older hardware, it can use what viewers or users see as TKIP, the Temporal Key Integrity Protocol.
 That's actually still RC4 running in the background, but they fixed the way it's being used so it's completely secure.
 But the alternative, and you'll see this sometimes in your user interface on your routers and maybe XP or something, depending on what your Wi-Fi stuff is, you may see AES as an alternative cipher.
 It's more compute intensive, so you will technically get a slower connection. And since it's sort of overkill, I don't use it and I don't even recommend it.
 You know, it is there and it's a block cipher. It was like the next generation sort of beyond DES as the formal, you know, worldwide standard.
 And boy, I mean, it has been pounded on extensively.
 So we know we shouldn't use DES, but triple DES is fine.
 Right.
 Blowfish is fine, IDEA.
 Are they all, you know, roughly equally strong?
 Well, there are various differences between them. They're generally all regarded as strong.
 Really, given a strong block cipher algorithm, the idea is that the only thing that should matter are the block length and the key length.
 That is a block length or a longer block length is generally better because it defeats any kind of frequency analysis by just muddying up any interrelationships and frequencies of the input bytes.
 It just mixes them up so much you can't see much statistical value in what comes out.
 Basically, it's turning what you put in into just random bits.
 You know, once again, that's the idea.
 And in fact, it's really interesting. A good measure of the quality of encryption is the compressibility of the output.
 Your output should not be compressible.
 The more random it is, the less you can compress it.
 Exactly.
 And so you want encryption to basically create a completely random output that isn't compressible because there's no patterns for a compressor to find in order to leverage,
 in order to squeeze down the result.
 So a modern block cipher like the AES chosen Rindall, for example, it allows you to use a key length of 128.
 I mean, it doesn't even have anything shorter than 128.
 It's like, OK, we're not doing less than 128 these days.
 So you can run it at 128, 192, or 256.
 Wow. And I mean, and so 256. I mean, that is just so beyond reason.
 I mean, but is it works?
 So why not?
 Is it compute intensive? I mean, is it so, you know, so compute intensive that you wouldn't want to use it?
 Or nowadays, should we just go ahead and, you know, use it?
 I guess it depends on your application.
 For example, our SSL connections are currently being encrypted with 128-bit security.
 And that's really sufficient because they're not static keys.
 That is every time I create a connection to a server, the handshaking that goes back and forth,
 which is so cool and we'll be talking about it in a couple of weeks.
 The both ends agree on a random 128-bit key just for that connection.
 And then it's scrapped and thrown away.
 And another one is chosen for the next connection.
 So the lifetime of these keys relative to their strength really renders them, you know, 128 bits is really strong.
 So, you know, yeah, a longer key length will generally require more processing, more hardware, more software, whatever.
 But our machines are so fast now that, you know, if you really wanted to use them, it's why, you know, why not?
 And in fact, that's what I've done with our open VPN configuration is I'm using 256-bit symmetric block encryption.
 Now, it's worth mentioning that these ciphers, these block ciphers are extremely fast relative to what we're going to be talking about next week,
 which are the so-called public key or asymmetric ciphers, where you use one key to encrypt and a different matching key to decrypt
 of, you know, hardware in the order of a thousand times faster, that is, the block ciphers are a thousand times faster than the public key systems.
 So these are, that's why they're also called bulk encryption ciphers. For example, it's the bulk IDEA is the chosen bulk encryption,
 as you mentioned, used for the commercial version of PGP, because they're very, very fast.
 You wouldn't want to transfer lots of data using asymmetric ciphers that we'll be talking about next week,
 because they're on the order of a thousand times slower. And so we'll talk about how these all work together as I was talking about with building blocks
 in order to give us a really cool set of possible functions.
 So there isn't any blanket recommendation that you would make for a particular technology. It really depends what you're doing.
 Well, it does, and for example, if a perfect example was Schneier's Blowfish, that is a very strong block cipher that he put in the public domain,
 it's available to everyone. Only recently did the patents on RSA's ciphers expire.
 So for example, you couldn't legally use RC4 or RC2 or RC5, which they had patents on.
 You couldn't use them without licensing them from them. Only now can you.
 And it's the same issue now with IDEA, which is patent-encumbered.
 Yes, exactly so. But in time you'll be able to use that as well.
 Yeah, and in fact, one of the requirements for any cipher that was adopted to be the AES, the Advanced Encryption Standard,
 it had to be released into the public domain. And this RC6 cipher that RSA put up for adoption, it is not publicly available.
 And they said, if our cipher, RC6 is adopted, then we will release it into the public domain, but otherwise not.
 So certainly one of the issues for choosing a block cipher or any cipher, stream or block cipher,
 is what are the licensing constraints, for example, the key lengths, the block size and so forth.
 So they have personalities and characteristics that when you were sitting down to choose what you wanted to do,
 those things would come into play.
 I always just take the default. I presume that whoever wrote G or PGP is picking the right one for me.
 Right, and I think that's probably a safe thing to do.
 So that really gets back to my fundamental question, which is they're all secure. They're all relatively secure.
 Well, generally, none of these have been cracked.
 You'll see people posting things saying that a cipher has been cracked.
 What that would really mean is that you could trivially determine the key or you could trivially reverse the encryption process.
 What's normally done is that or mean when they say cracked is that once upon a time through a tremendous effort,
 one key was determined in some sort of a challenge.
 And for example, companies like RSA create public challenges saying, you know, we'll offer prizes.
 We'll offer recognition to academic establishments and anyone who wants to try to come up with the key.
 So they'll say, here's the cipher we're using. Here's the plain text.
 Here's the cipher text. What is the key that we used in order to produce this?
 And it's one of the ways that these ciphers are strengthened is just by giving some incentive for people to pound on them
 and see if there's some way to break them or crack them.
 None of these have been cracked, although cracked meaning that it's basically rendered worthless.
 What has happened is that the shorter key lengths have been brute force attacked, and that's the idea.
 You want an algorithm where there is no choice other than to try every single key.
 And then all you need to do is have a bit length on your key that is so long that every single key becomes virtually impractical in the lifetime of the universe.
 You know, what was it, 10 to the 19 years?
 You're right about people coming up with kind of crazy schemes in his book, "Cryptonomacom."
 Neil Stevenson claims to come up with a very strong encryption technique involving a pack of cards.
 And the point is, yeah, there are lots of different algorithms, but if you stick to these half dozen well-known, strong algorithms,
 chances are they are strong because so many people are attacking them and trying to break them.
 And any time you wander off the trail and try something cute, you really open yourself to vulnerability.
 As the engineers who designed wept learned to their discipline.
 There just isn't a reason not to use these.
 I mean, it's like this problem is solved.
 You know, no one needs to do new crypto because really, really strong algorithms with long bit lengths,
 which have been well proven, are in the public domain. They're free to use. Why not use them?
 Always a pleasure, Steve. This is a fascinating subject.
 And I think we could go do many, many more episodes on crypto.
 I think people are very interested in it.
 It's something that both captures the kind of imagination of the laymen
 and also has some real practical import for any of us who use digital technology.
 Well, in a digital world, Leo, we are dependent upon the privacy and the security of the data we store
 and the messages we send, you know, and more and more as people are, for example, configuring Wi-Fi.
 They're checking their SSL certificates to see to make sure that the site they're connecting to is what they think it is.
 You know, these cryptographic concepts are entering and impinging on people's lives.
 So it's important. And in the coming weeks, we're going to move through this exactly as we have been.
 And by the time we're done, people who've been following along, they're going to get all this stuff.
 They're going to mean it's what's so cool about it is it's not hard to understand.
 Here, we've just explained in a very useful fashion, you know, symmetric block ciphers.
 Everyone who's been listening gets it now. And then we're going to talk about how you use these.
 Well, I mean, no one's writing one of these algorithms, but that's the point. That's not necessary.
 Right. Yep. Right. We don't need to.
 In fact, it also inspires us to, as you said, to check and make sure and upgrade.
 And because of this, I went out and I looked at my -- I've always used some form of digital signing on my emails
 and I upgraded it to the latest version of GPG, the new privacy card, because I want to make sure I had the latest version.
 And I sign all my emails digitally and encrypt many of them if people give me their key.
 So I think it's a nice thing to have available to you.
 Yeah. Hey, thank you, Steve. Next week, what do we want to talk about?
 Next week is asymmetric ciphers, so-called public key cryptography.
 And that's what I'm using, of course.
 Well, actually, you're using symmetric. You don't know it, but you are.
 The one who is using public key is also using private keys or symmetric, because for reasons we will cover next week.
 All will become clear. And Steve, we've got to do more stumpers. People obviously like them.
 Well, when I can think of something, or when someone presents something, I agree.
 It was a fun thing. Stum Steve, and we'll offer it to the group as a whole.
 Of course, you can get more information on all of these subjects at Steve's website, grc.com/securitynow.com.
 That's also the home of Spinrite. Steve's fantastic disk recovery and maintenance utility.
 It must have for every user. Anybody who's got a PC should have Spinrite.
 And you can find out more about it at SpinriteSPINRITE.info.
 And if you're looking for transcripts or 16-kilobit versions of this show or show notes again, grc.com/securitynow.html.
 We thank our good friends at America Online for broadcasting this show on their podcast channel on the AOL radio.
 And you can find out more about that at AOL.com/podcasting.
 And we'll see you next week on Security Now.
 Look forward to it, Laggy Steve.
 Security Now!
